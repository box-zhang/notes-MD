# 解决

![image-20200402101652934](/Users/zhangml/Library/Application Support/typora-user-images/image-20200402101652934.png)

## 产生跨域的原因

1. 浏览器的限制	

   浏览器出于安全的考虑，当他发现请求是跨域的时候会做一些校验，如果校验不通过，就会报跨域安全问题的错误。而服务器的后台实际是没有任何限制，被请求到了且返回成功，只是浏览器单方面阻断了请求值的返回

2. 请求是跨域的

   发出的请求不是本域的，在请求里面，协议、域名、端口，任何一个不一样，浏览器都认为是跨域

3. 请求的条件是 XHR（XMLHttpRequest）请求（调用接口的请求）

   也就是说你发出去不是XHR请求的话，就不会报错

## 解决思路

1. 浏览器限制

   通过终端输入指定参数，让浏览器不去做这个校验，就可以避免，但是这种方式只能改变某个人的跨域请求，每个用户都有一个终端，这样解决没有什么意义

2. XHR

   只要发出去的是XHR请求，我们使用JSONP方式进行解决，因为浏览器通过JSONP发出去的是script请求，如果浏览器检测到发出去的不是XHR格式内容，就不会做校验。但是基于JSONP的请求有很多弊端，他无法满足现在的开发需求，所以用的越来越少了

3. 跨域

   - 被调用方修改代码。让后端支持跨域。修改的是被调用方的http服务器

     是基于http协议，关于跨域方面的要求来做的修改，也就是A域名调用B域名时，在B域名返回的信息里面加入一些字段告诉浏览器我允许A域名调用，那么浏览器只要通过校验，就不会出现跨域安全问题的报错。

     那么假如B调用方，不是自己公司的，无法修改怎么办呢，这就可以通过调用方进行修改。

   - 调用方。让前端隐藏跨域。修改的是调用方的http服务器

     通过代理，从浏览器发出去的都是A域名的请求，在代理里面把A域名里面指定的的url转到B域名里面，在浏览器看上去就是同一个域名。

### 1、浏览器方法

~~~javascript
$
~~~

### 2、JSONP方法

普通请求和JSONP请求的区别：

- 普通的请求，发出的是xhr格式内容，JSONP发出去的是script请求。

- 普通的请求，返回的是json对象，而JSONP请求，返回的是js脚本。
- 普通请求的url就是简单的，而JSONP的url后面会自动添加带有“?callback=……”参数的一长串内容，也就是一种约定，就是说前后端约定好，只要后端接收到的有`callback`的参数，他就知道前端请求的是JSONP请求，他就自动将要返回的数据由json对象变为javascript代码，而javascript的内容就是一个函数调用。（callback是一种约定，不能随意更改，如果要更改，就前后端都要改才可以） 

~~~javascript
//使用jasmine框架帮助进行跨域校验

it("jsonp请求"，function(done){
  var result;	//服务器返回的结果
  $.ajax({
    url:base + "/get",
    dataType:"jsonp",	//请求的格式
    jsonp:"callback2",	//此处如果不写，则默认callback，如果定义了别的参数名，后端也需要同步jsonp的参数名
    cache:true,	//结果可以被缓存，如果不加这句话， 结果不会被缓存，每次返回值后面都会多一个 下划线+随机数 ，这样结果就不会被缓存
    success:function(json){
      result=json;
    }
  })

  //由于是异步请求，所以需要用setTimeout来校验
  setTimeout(function(){
		expect(result).toEqual({
      "data": "get OK"
    })
    // 校验完成，通知jasmine框架
    done()
  },100)
  
})
~~~

####JSONP有什么弊端

1. 服务器需要改动代码支持
2. 只支持get请求的jsonp
3. 发送的不是XHR请求

### 3、被调用方解决-支持跨域

- 服务器端实现
- NGINX配置
- APACHE配置

### 4、调用方解决-隐藏跨域

- 使用代理，配置host，使用的时候，要使用代理之后的地址
- 通过APACHE的反向代理

------

学习网址：慕课网-晓风轻[https://www.imooc.com/learn/947]

